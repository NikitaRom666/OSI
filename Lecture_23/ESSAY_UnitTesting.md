# Юніт-тестування: теорія та практика

## Вступ

Коли я почав вивчати програмування, мені казали писати код, але ніхто не говорив як переконатися, що цей код насправді працює правильно. Потім я дізнався про юніт-тестування. Спочатку це здавалося чимось складним і непотрібним — на що витрачати час на написання тестів, коли можна просто запустити програму й перевірити, чи вона працює? Але коли проєкт почав расти, і я почав робити найглупніші помилки, я зрозумів, що тести — це насправді спасіння.

Це есе розповім про те, що таке юніт-тестування, як його правильно робити, та чим воно відрізняється від інтеграційного тестування.

## Що таке юніт-тестування?

Юніт-тестування — це перевірка окремих, найменших одиниць коду. Зазвичай це один метод або функція. Ідея в тому, що ми беремо один метод, даємо йому вхідні дані, дивимося, що він повертає, і перевіряємо, чи це те, що ми очікували.

Наприклад, якщо у мене є метод `Sum(int a, int b)`, я можу написати тест:
```csharp
[Fact]
public void Sum_WithPositiveNumbers_ReturnsCorrectSum()
{
    // Arrange
    int a = 5;
    int b = 3;
    
    // Act
    int result = Sum(a, b);
    
    // Assert
    Assert.Equal(8, result);
}
```

Цей тест перевіряє, що коли я додаю 5 і 3, я отримую 8. Просто, правда? Але коли таких тестів сотні, вони рятують тебе від багатьох проблем.

## Переваги юніт-тестування

**1. Ловиш помилки рано**

Замість того, щоб запустити всю програму, чекати, коли вона завантажиться, потім кліцати по інтерфейсу і нарешті знайти баг — ти пишеш тест, запускаєш щоб зберегти файл, і за секунду дізнаєшся, що щось не так. Це економить багато часу.

**2. Документація коду**

Коли я читаю тести, я бачу, як мав б використовуватися код. Це краще, ніж читати коментарі, бо тести показують реальні приклади.

**3. Рефакторинг стає менш страшним**

Раніше я боявся змінювати старий код, бо не знав, чи щось не зломаю. Тепер, коли у мене є тести, я можу змінювати код, переписувати логіку, і якщо я щось порушив — тести мені скажуть.

**4. Спроектувати краще**

Коли ти пишеш тести ще до коду (це називається TDD — Test-Driven Development), ти змушений думати про те, як твій метод має працювати. Це робить код чистішим і краще структурованим.

**5. Підтримка коду**

Коли хтось інший (або ти після 6 місяців) буде змінювати код, тести скажуть йому/їй, що может зломатися.

## Обмеження юніт-тестування

Але юніт-тестування не волшебство. У нього є обмеження.

**1. Не ловить проблеми інтеграції**

Юніт-тесты перевіряють одиниці коду окремо. Але що коли два модулі взаємодіють? Що коли метод A викликає метод B, а B викликає базу даних? Юніт-тест методу A може пройти, але інтеграція може бути сломана.

Наприклад:
- Метод `GetUserById(1)` працює в тесті, але база даних повертає іншу схему даних, ніж ми очікуємо
- API викликає правильно, але сервер очікує інший формат

Для цього потрібні інтеграційні тести.

**2. Потребує більше часу на написання**

Якщо у мене є 10 методів, і я хочу написати по 2-3 тести для кожного, то я написав 20-30 тестів. Це може зайняти багато часу.

**3. Может дати хибне відчуття безпеки**

Ти написав 100 тестів, 99 з них проходять... але це не означає, що твоя програма працює ідеально. Ти міг написати тести на щось некритичне, або забути тестувати важливий сценарій.

**4. Хитро з залежностями**

Якщо твій метод залежить від бази даних, мережі, файлової системи — то тестування ускладнюється. Потрібно використовувати mock-об'єкти або фіксші відібраний набір даних.

## Юніт-тестування vs Інтеграційне тестування

Це важливо розуміти різницю.

### Юніт-тести
- Тестують **одну сутність** (метод, функцію, клас)
- Роблять це **швидко** (мілісекунди)
- **Ізольовані** від зовнішніх залежностей
- Занадто **деталізовані**
- Не перевіряються зовнішні системи

Приклад: Тест методу `CalculateDiscount()`

### Інтеграційні тести
- Тестають **кількька частини разом**
- Можуть взаємодіяти з **реальною БД**, файловою системою, АПІ
- Роблять це **повільніше** (секунди часто)
- Показують **реальні сценарії** використання
- Виловлюють проблеми між модулями

Приклад: Тест користувача який замовляє товар — від пошуку товару, перевірки ціни до збереження замовлення в БД

### Скільки чого потрібно?

Часто люди кажуть про "пірамідою тестування":

```
          /\
         /  \  E2E тесты (мало)
        /____\
       /      \  Інтеграційні тесты (середньо)
      /________\
     /          \  Юніт-тесты (багато)
    /____________\
```

Більшість тестів — це юніт-тести, тому що вони швидкі. Суть в тому, що юніт-тести ловять 80% помилок, але без інтеграційних тестів ти пропустиш 20%, які найскладніше дебажити.

## Коли використовувати mock-об'єкти?

Mock-об'єкти — це підробні версії реальних об'єктів, які ми використовуємо в тестах.

### Коли вони потрібні (мають використовувати):

**1. База даних**
```csharp
// Реальна БД повільна та непередбачувана в тестах
// Користуємо mock
var mockDatabase = new Mock<IDatabase>();
mockDatabase.Setup(db => db.GetUser(1))
    .Returns(new User { Id = 1, Name = "John" });
```

**2. Зовнішні АПІ**
```csharp
// Не хочемо робити справжні http запити під час тестування
var mockHttpClient = new Mock<IHttpClient>();
mockHttpClient.Setup(c => c.Get("https://api.example.com"))
    .Returns(new Response { Status = "Success" });
```

**3. Файлова система**
```csharp
// Не хочемо створювати справжні файли під час тесту
var mockFileSystem = new Mock<IFileSystem>();
mockFileSystem.Setup(fs => fs.ReadFile("test.txt"))
    .Returns("file content");
```

### Коли без них можна обійтися (не потрібні):

**1. Прості математичні операції**
```csharp
// Просто тестуємо метод
int result = Calculator.Add(2, 3);
Assert.Equal(5, result);
// Тут mock не потрібен
```

**2. Коли об'єкт простий і не має побічних ефектів**
```csharp
var user = new User { Name = "John", Age = 30 };
Assert.Equal("John", user.Name);
// Тут мок не потрібен
```

**3. Інтеграційні тести**
```csharp
// В інтеграційних тестах ми часто користуємо справжню БД
// (або тестову копію), а не моки
var actualDatabase = new Database();
var user = actualDatabase.GetUser(1);
Assert.NotNull(user);
```

## Мій висновок

Юніт-тестування — це не щось дивне, що тільки занудні програмісти роблять. Це інструмент, який дійсно допомагає. Спочатку писати тести важко, але коли ти звикнеш, ти не захочеш повертатися до кодування без них.

Якщо ти пишеш проєкт самостійно — можеш писати більше юніт-тестів. Якщо працюєш у команді — тести жизненно необхідні. Вони дозволяють іншим людям переконатися, що твій код працює, і дозволяють тобі змінювати чужий код без страху.

Що стосується mock-об'єктів — користуй їх коли тестуєш речі, які залежять від зовнішnizацshkuuных систем. Для простих сценаріїв вони не потрібні.

Найголовніше — почнути писати тести. Перший тест буде найскладнішим, але потім стане легше.
